---
title: "Sibling rivalry vs mother’s curse: can kin competition facilitate a response to selection on male mitochondria?"  
author: "Thomas A Keaney, Heidi WS Wong, Damian K Dowling, Therésa M Jones and Luke Holman"
bibliography: "supp_references.bib"
subtitle: Supplementary material
output:
  html_document:
    code_folding: hide
    depth: 1
    number_sections: no
    theme: yeti
    toc: yes
    toc_float: yes
    code_download: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE, warning = FALSE, message = FALSE)
```

Published in _Proceedings of the Royal Society B_

Article DOI: 10.1098/rspb.2020.0575

# Load all required packages

```{r, load packages}

library(png) # to load images
library(grid) # to plot images
library(lme4) # for the lmer and glmer mixed model functions
library(lmerTest) # Used to get p-values for lmer models using simulation. It over-writes lmer() with a new version, which gives p-values
library(emmeans) # for pairwise comparisons
library(glmmTMB) # for zero-inflated or hurdle glms
library(MuMIn) # for model selection and averaging
library(tidyverse) # data re-shaping, ggplot, stringr and more
library(ggridges) # for joy plots
library(ggpubr) # for the ggarrange function
library(ggbeeswarm) # violin plots with data points
library(kableExtra) # nice tables that can scroll
library(pander) # more nice tables
library(groupdata2) # for assigning rows in data-frames to groups

```


# Supplementary methods

Schematic for replacement of the unknown _Sxl-GFP_ nuclear background with the isogenic _w^1118^_ background

```{r fig.width=6, fig.height=8}

img <- readPNG("Crossing_scheme.png")
 grid.raster(img)
```

**Figure S1**: Crossing scheme used to create a standard homozygous _w^1118-GFP^_ line. Males from this line were crossed with females carrying a specific mitochondrial haplotype, to create experimental _mt_-strains. These newly produced strains carried the mitochondrial haplotype of the female and were heterozygous for the _Sxl-GFP_ construct. G1 = the first generation of the cross.



**Table S1**: Recipe for food medium used in our experiment. The provided quantities make ~ 1 litre of food.

```{r, food recipe}

tibble("Ingredients" = c("Soy flour", "Cornmeal", "Yeast", "Dextrose", "Agar", "Water", "Tegosept", "Acid mix"),
       "Quantity" = c("20 g", "73 g", "35 g", "75 g", "6 g", "1000 mls", "17 mls", "14 mls")) %>% 
  pander()

```



# Data analysis and supplementary results


Here we include all code used to run our analysis and create Figure 1 and 2, our rationale behind the modelling approaches, and tables S2-9.

#### Read in the data and create some helpful functions


```{r data and functions}

# Read in data frame and add Dyad_ID column

all_data <- read.csv("mtDNA_larval_competition_data.csv") %>% 
  arrange(Individual) %>%
  group(n = 2, method = "greedy") %>% rename(Dyad_ID = .groups)

# helper function for saving large model objects and naming the file object.rds

save_it <- function(object){
  saveRDS(get(object), file = paste(object, ".rds", sep = ""))}

# Create a function for standard error

SE <- function(x) sd(x)/sqrt(length(x))

```


#### Data preparation for all responses

```{r data cleaning}

# Clean the dataset up for analysis

# Select the columns we're interested in and rename them

fitness_data <- dplyr::select(all_data, Individual, Block, Strain,  Dyad_ID, Sex, Focal.haplotype, Social.haplotype, Mortality, Development.time..hrs., Wing.size..mm., Female.offspring, Male.offspring, Total.female.assay, Total.red.all.vials, Total.bw.all.vials, Proportion.red.all.vials) %>% 
  
rename(Block = Block, Survived = Mortality, Focal_haplotype = Focal.haplotype, Social_haplotype = Social.haplotype, Dev_time = Development.time..hrs., Wing_length = Wing.size..mm., Maternal_female_offspring = Female.offspring, Maternal_male_offspring = Male.offspring, Maternal_total_offspring = Total.female.assay, Paternal_focal_offspring = Total.red.all.vials, Paternal_bw_offspring = Total.bw.all.vials, Proportion_focal = Proportion.red.all.vials)

# Define new levels for mortality to make renaming possible 

levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "NO")
levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "YES")

# Rename the mortality responses
# L means died as larva, P means died as pupae, N means did not die (i.e. eclosed as an adult)

fitness_data$Survived[fitness_data$Survived == 'L'] <- 'NO'
fitness_data$Survived[fitness_data$Survived == 'P'] <- 'NO'
fitness_data$Survived[fitness_data$Survived == 'N'] <- 'YES'

# Now that it makes sense change "YES" to 1 and "NO" to 0 so we can fit a binomial GLM.

levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "1")
levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "0")

fitness_data$Survived[fitness_data$Survived == "YES"] <- 1
fitness_data$Survived[fitness_data$Survived == "NO"] <- 0

# Make the factor numeric 

fitness_data$Survived <- as.numeric(as.character(fitness_data$Survived))


# Create specific datasets for each fitness trait

# Remove all rows that contain an NA value in the survival column. The NAs mean things like the GFP sorting did not work, or the vial was never set up due to a shortage of larvae. They are not meaningful data, and we remove them here.

survival <- fitness_data %>% filter(!is.na(Survived)) 
  
# Remove all rows that contain an NA value in the development time column. This instances represent flies where we failed to measure development time. 

larval_development <- fitness_data %>% filter(!is.na(Dev_time)) 

# Remove all rows that contain an NA value in the wing length column. Wing length was not measured in Blocks 1 and 2.

body_size <- fitness_data %>% filter(!is.na(Wing_length)) 

# Remove all rows that contain an NA value in the female reproductive output column (e.g. all the males), and where females did not survive to adulthood (coded as producing 0 offspring). 

female_reproductive_output <- fitness_data %>% filter(!is.na(Maternal_total_offspring), Survived == 1)


# Male adult fitness

# First remove females from the dataset.

Male_fitness <- fitness_data %>% filter(!is.na(Paternal_focal_offspring)) 

# Create an offspring counted column so that the data is correctly formatted for a binomial success-failure model.

Male_fitness$Offspring_counted <- Male_fitness$Paternal_focal_offspring + Male_fitness$Paternal_bw_offspring

# Now lets remove vials where the female produced 0 offspring (this includes trials where the male died in development), as we cannot determine paternity from these vials. The tidy up the dataframe by removing unneccessary columns

Male_fitness <- Male_fitness %>% filter(!(Offspring_counted == 0)) %>% 
  select(-Maternal_female_offspring, -Maternal_male_offspring, -Maternal_total_offspring) %>% 
  rename(Focal_male_offspring = Paternal_focal_offspring, bw_male_offspring = Paternal_bw_offspring)

```


## Modelling approach

We analysed the data using linear and generalised linear mixed models in the `lmer` and`glmmTMB` packages for R.

**Fixed effects**

For the analysis of fitness traits expressed in both sexes (survival, development time and body size), we are interested in the effect of an individual’s focal mtDNA, the mtDNA of a social competitor and the effect of sex on fitness. To measure these potential effects each model contained the following fixed effects and the three-way interaction between these variables:

Focal haplotype: the mtDNA haplotype that an individual carries.

Social haplotype: the mtDNA haplotype carried by a social partner during larval development.

Sex: the sex of the focal individual. The social partner's sex was always opposite to that of the focal individual.

**Random effects**

Duplicate strain: Each haplotype has been introgressed alongside the _w^1118^_ nuclear background in two independent duplicates, creating 10 total strains. Within each block we ran multiple replicates that were made up of flies from the first set of strains (i.e. Barcelona 1, Brownsville 1 etc.), while the other half used only flies from the second set of strains. This random effect accounts for any residual differences in the nuclear genome, epigenome, microbiome or vial environment that may have arisen between duplicates.

Block: accounts for differences in the response variable between experimental blocks (e.g. to variance in temperature or composition of the fly food). In our experiment a block contained multiple replicates and a replicate was made up of 25 different cells each housing a pair of larvae.

Dyad ID: accounts for differences in the quality of the larval environment between pairs of larvae. For example, the moisture content of the food varied between pipette tips, despite our best efforts to keep this variable constant.  

**Model evaluation**

Each model was evaluated and ranked by AICc values using the `dredge` function, from the `Mumin` package. There was rarely a single model that was unequivocally the best fit to the data, so we conducted model averaging for the set of models where delta was < 6, as suggested by Symonds and Moussalli [-@RN455]. The present study is a planned experiment to measure the effect of mtDNA on fitness, so we derived model estimates from the conditional model averages.

$~$


## Larval fitness measures

$~$


### Egg to adult viability analysis
* * *

The model:

_Survival ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID)_

```{r survival model}

# Fit the global model

survival_model <- lme4::glmer(Survived ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), data = survival, family = "binomial", control = glmerControl(optimizer = "Nelder_Mead", optCtrl=list(maxfun=100000)), na.action = na.fail)

```

#### Model evaluation

**Table S2**: Evaluation of the survivorship model. All possible models were evaluated from the global model that included a three-way interaction between focal haplotype, social haplotype and sex, as well as the random factors duplicate strain, block and dyad ID. As there was no clear top model, the final model was calculated via model averaging.

```{r survival dredge table}

# Compare all possible combinations of models (from the global model)

if(file.exists("survival_dredge.rds")){ # If already done, just load the results
  survival_dredge <- readRDS("survival_dredge.rds")
} else {survival_dredge <- dredge(survival_model) # If not already done, run all the models and save the results
lapply(c("survival_dredge"), save_it)
}


survival_table <- subset(survival_dredge, delta < 6, recalc.weights = FALSE) %>% as.data.frame()

names(survival_table)[names(survival_table) == "(Intercept)"] <- "Intercept"
names(survival_table)[names(survival_table) == "Focal_haplotype"] <- "Focal haplotype"
names(survival_table)[names(survival_table) == "Sex"] <- "Sex"
names(survival_table)[names(survival_table) == "Social_haplotype"] <- "Social haplotype"
names(survival_table)[names(survival_table) == "Focal_haplotype:Sex"] <- "Focal haplotype x Sex"
names(survival_table)[names(survival_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(survival_table)[names(survival_table) == "Sex:Social_haplotype"] <- "Social haplotype x Sex"
names(survival_table)[names(survival_table) == "Focal_haplotype:Sex:Social_haplotype"] <- "Focal haplotype x Social haplotype x Sex"
names(survival_table)[names(survival_table) == "df"] <- "Degrees of freedom"
names(survival_table)[names(survival_table) == "logLik"] <- "Log likelihood"
names(survival_table)[names(survival_table) == "AICc"] <- "AICc"
names(survival_table)[names(survival_table) == "delta"] <- "Delta"
names(survival_table)[names(survival_table) == "weight"] <- "Weight"

pander(survival_table, split.cell = 40, split.table = Inf)
```

$~$


Relative variable importance for each of the predictors and interactions in the survival model set. RVI can be interpreted as the likelihood the model term is present in the best performing model from the initial full set of possible models.

```{r, survival RVI}

# present relative variable importance in a table 

sw(survival_dredge) %>%
  as.data.frame() %>%
  pander(split.cell = 40, split.table = Inf, round = 3, col.names = "RVI")
```

$~$


#### Model averaging

**Table S3**: Effects of mtDNA and sex on egg-to-adult viability.  Conditional estimates from model averaging the full generalised linear mixed model are shown. Models were included in the averaging subset if delta < 6. Bold rows indicate significant effects. 

```{r survival model averaging}

# Model average

# We need to create the top_survival_models object and average from that so that we can get mean estimates successfully using predict(), fitted() or eemeans()

top_survival_models <- get.models(survival_dredge, subset = delta < 6)

survival_avgm <- model.avg(top_survival_models)

# average the models with delta < 6

survival_CIs <- confint(survival_avgm) %>% as.data.frame()

survival_estimate <- coefTable(survival_avgm) %>% as.data.frame()

survival_p_values <- summary(survival_avgm)$coefmat.subset[, 5] %>% as.data.frame() %>% rename(p = ".")

survival_model_avg <- data.frame(survival_estimate, survival_CIs, survival_p_values) %>% select(Estimate, Std..Error,  X2.5.., X97.5.., p)

row.names(survival_model_avg) <- c("Intercept", "Sex: Male", "Focal haplotype: Brownsville", "Focal haplotype: Dahomey", "Focal haplotype: Israel", "Focal haplotype: Sweden", "Social haplotype: Brownsville", "Social haplotype: Dahomey", "Social haplotype: Israel", "Social haplotype: Sweden")

names(survival_model_avg)[names(survival_model_avg) == "Estimate"] <- "Conditional average estimate"
names(survival_model_avg)[names(survival_model_avg) == "Std..Error"] <- "Standard Error"
names(survival_model_avg)[names(survival_model_avg) == "X2.5.."] <- "2.5% Interval"
names(survival_model_avg)[names(survival_model_avg) == "X97.5.."] <- "97.5% Interval"

pander(survival_model_avg, split.cell = 40, split.table = Inf, round = 3)

# The full average provides a parameter average across all models considered, including ones where the parameter coefficient is set to 0. The conditional average reports coefficents for only the models where the parameter is included.

```

#### Comparison of focal and social haplotype effect sizes {.tabset}

While our experiment was not designed to calculate estimates of conventional selection and social selection, we present the standardised effect size for the difference in mean fitness between haplotype pairs, for direct and indirect fitness effects. While our power is low when making these contrasts, the aim here is to illustrate that the size of the direct and indirect effects on viability are of similar magnitudes.

##### Focal haplotype effect sizes

```{r}
# Fit a simplified version of the mode without interactions that can be used with the emmeans() function. This model is reasonable as we detected no evidence for an interaction between any of our fixed effects in the above analysis.

survival_emmeans <- glmer(Survived ~ Focal_haplotype + Social_haplotype + Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), data = survival, family = "binomial", control = glmerControl(optimizer = "Nelder_Mead", optCtrl=list(maxfun=100000)), na.action = na.fail)

# Now create the pairwise comparisons for focal haplotype

pairs(emmeans(survival_emmeans, ~ Focal_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

##### Social haplotype effect sizes

```{r}
# Now for social haplotype

pairs(emmeans(survival_emmeans, ~ Social_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```


$~$


### Development time analysis
* * *

The model:

_Dev_time ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID)_

```{r dev time model}

# Fit the linear model

dev_model <- lmer(Dev_time ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), larval_development, na.action = na.fail, REML = FALSE)

```

#### Model evaluation

**Table S4**: Evaluation of the development time model. All possible models were evaluated from the global model that included a three-way interaction between focal haplotype, social haplotype and sex as well as the random factors duplicate strain, block and dyad ID. As there was no clear top model, the final model was calculated via model averaging.

```{r dev time dredge table}
# Use dredge to compare all possible models derived from the global model

Dev_dredge <- dredge(dev_model)

development_table <- subset(Dev_dredge, delta < 6, recalc.weights = FALSE)  %>% as.data.frame()

names(development_table)[names(development_table) == "(Intercept)"] <- "Intercept"
names(development_table)[names(development_table) == "Focal_haplotype"] <- "Focal haplotype"
names(development_table)[names(development_table) == "Social_haplotype"] <- "Social haplotype"
names(development_table)[names(development_table) == "Focal_haplotype:Sex"] <- "Focal haplotype x Sex"
names(development_table)[names(development_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(development_table)[names(development_table) == "Sex:Social_haplotype"] <- "Social haplotype x Sex"
names(development_table)[names(development_table) == "Focal_haplotype:Sex:Social_haplotype"] <- "Focal haplotype x Social haplotype x Sex"
names(development_table)[names(development_table) == "df"] <- "Degrees of freedom"
names(development_table)[names(development_table) == "logLik"] <- "Log likelihood"
names(development_table)[names(development_table) == "AICc"] <- "AICc"
names(development_table)[names(development_table) == "delta"] <- "Delta"
names(development_table)[names(development_table) == "weight"] <- "Weight"

pander(development_table, split.cell = 40, split.table = Inf)

```

$~$


Relative variable importance for each of the predictors and interactions in the development time model set.

```{r, dev time RVI}

# present relative variable importance in a table 

sw(Dev_dredge) %>%
  as.data.frame() %>%
  pander(split.cell = 40, split.table = Inf, round = 3, col.names = "RVI")
```

$~$


#### Model averaging

**Table S5**: Effects of mtDNA and sex on egg-to-adult development time.  Conditional estimates from model averaging the full generalised linear mixed model are shown. Models were included in the averaging subset if delta < 6. Bold rows indicate significant effects.

```{r dev time model averaging}

# Model averaging

Dev_time_avg <- (model.avg(Dev_dredge, subset = delta < 6))

Dev_CIs <- confint(Dev_time_avg) %>% as.data.frame()

Dev_estimate <- coefTable(Dev_time_avg) %>% as.data.frame()

Dev_p_values <- summary(Dev_time_avg)$coefmat.subset[, 5] %>% as.data.frame() %>% rename(p = ".")

Dev_model_avg <- data.frame(Dev_estimate, Dev_CIs, Dev_p_values) %>% select(Estimate, Std..Error,  X2.5.., X97.5.., p)

row.names(Dev_model_avg) <- c("Intercept", "Sex: Male", "Focal haplotype: Brownsville", "Focal haplotype: Dahomey", "Focal haplotype: Israel", "Focal haplotype: Sweden", "Social haplotype: Brownsville", "Social haplotype: Dahomey", "Social haplotype: Israel", "Social haplotype: Sweden")

names(Dev_model_avg)[names(Dev_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Dev_model_avg)[names(Dev_model_avg) == "Std..Error"] <- "Standard Error"
names(Dev_model_avg)[names(Dev_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Dev_model_avg)[names(Dev_model_avg) == "X97.5.."] <- "97.5% Interval"


pander(Dev_model_avg, split.cell = 40, split.table = Inf, emphasize.strong.rows = 2, round = 3)

```

#### Comparison of focal and social haplotype effect sizes {.tabset}

While our experiment was not designed to calculate estimates of conventional selection and social selection, we present the standardised effect size for the difference in mean fitness between haplotype pairs, for direct and indirect fitness effects. While our power is low when making these contrasts, the aim here is to illustrate that the size of the direct and indirect effects on development time are of similar magnitudes.

##### Focal haplotype effect sizes

```{r}
# Fit a simplified version of the mode without interactions that can be used with the emmeans() function. This model is reasonable as we detected no evidence for an interaction between any of our fixed effects in the above analysis.

dev_time_emmeans <- lmer(Dev_time ~ Focal_haplotype + Social_haplotype + Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), larval_development, na.action = na.fail, REML = FALSE)

# Now create the pairwise comparisons for focal haplotype

pairs(emmeans(dev_time_emmeans, ~ Focal_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

##### Social haplotype effect sizes

```{r}
# Now for social haplotype

pairs(emmeans(dev_time_emmeans, ~ Social_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```


$~$


## Adult fitness measures

$~$


### Body size analysis
* * *

We use wing length as a proxy for adult body size.

The model:

_Wing_length ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID)_


```{r size model}

body_size_model <- lmer(Wing_length ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), body_size, na.action = na.fail, REML = FALSE)

```

#### Model evaluation

**Table S6**: Evaluation of the wing length model. All possible models were evaluated from the global model that included a three-way interaction between focal haplotype, social haplotype and sex, as well as the random factors duplicate strain, block and dyad ID. There was a clear top model; coefficients are displayed in Table S7.
```{r size dredge table}

# Compare all possible combinations of models (from the global model)

body_size_dredge <- dredge(body_size_model)

size_table <- subset(body_size_dredge, delta < 6, recalc.weights = FALSE) %>% as.data.frame()


names(size_table)[names(size_table) == "(Intercept)"] <- "Intercept"
names(size_table)[names(size_table) == "Focal_haplotype"] <- "Focal haplotype"
names(size_table)[names(size_table) == "Sex"] <- "Sex"
names(size_table)[names(size_table) == "Social_haplotype"] <- "Social haplotype"
names(size_table)[names(size_table) == "Focal_haplotype:Sex"] <- "Focal haplotype x Sex"
names(size_table)[names(size_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(size_table)[names(size_table) == "Sex:Social_haplotype"] <- "Social haplotype x Sex"
names(size_table)[names(size_table) == "Focal_haplotype:Sex:Social_haplotype"] <- "Focal haplotype x Social haplotype x Sex"
names(size_table)[names(size_table) == "df"] <- "Degrees of freedom"
names(size_table)[names(size_table) == "logLik"] <- "Log likelihood"
names(size_table)[names(size_table) == "AICc"] <- "AICc"
names(size_table)[names(size_table) == "delta"] <- "Delta"
names(size_table)[names(size_table) == "weight"] <- "Weight"

pander(size_table, split.cell = 40, split.table = Inf)

```

$~$


Relative variable importance for each of the predictors and interactions in the wing length model set.

```{r, size RVI}

# present relative variable importance in a table 

sw(body_size_dredge) %>%
  as.data.frame() %>%
  pander(split.cell = 40, split.table = Inf, round = 3, col.names = "RVI")
```

$~$



#### Best fitting model

One model was retained in the delta < 6 subset; model averaging is not required.

**Table S7**: Effects of mtDNA and sex on wing length. Results from the best fitting generalised linear mixed model are shown. Bold rows indicate significant effects.

```{r size best model}

# Fit the top model

body_size_model_final <- lmer(Wing_length ~ Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), body_size, na.action = na.fail, REML = FALSE)

Size_CIs <- confint(body_size_model_final) %>%
  as.data.frame() %>% 
  slice(5:6)

Size_estimate <- coefTable(body_size_model_final) %>% as.data.frame()

Size_p_values <- summary(body_size_model_final)$coefficients[, 5] %>% as.data.frame() %>% rename(p = ".")

Size_model_avg <- data.frame(Size_estimate, Size_CIs, Size_p_values) %>% select(Estimate, Std..Error,  X2.5.., X97.5.., p)

row.names(Size_model_avg) <- c("Intercept", "Sex: Male")

names(Size_model_avg)[names(Size_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Size_model_avg)[names(Size_model_avg) == "Std..Error"] <- "Standard Error"
names(Size_model_avg)[names(Size_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Size_model_avg)[names(Size_model_avg) == "X97.5.."] <- "97.5% Interval"

pander(Size_model_avg, split.cell = 40, split.table = Inf, emphasize.strong.rows = (2), round = 3)

```

$~$

#### Comparison of focal and social haplotype effect sizes {.tabset}

While our experiment was not designed to calculate estimates of conventional selection and social selection, we present the standardised effect size for the difference in mean fitness between haplotype pairs, for direct and indirect fitness effects. While our power is low when making these contrasts, the aim here is to illustrate that the size of the direct and indirect effects on body size are minimal and of similar magnitudes.

##### Focal haplotype effect sizes

```{r}
# Fit a simplified version of the mode without interactions that can be used with the emmeans() function. This model is reasonable as we detected no evidence for an interaction between any of our fixed effects in the above analysis.

size_emmeans <- lmer(Wing_length ~ Focal_haplotype + Social_haplotype + Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), body_size, na.action = na.fail, REML = FALSE)

# Now create the pairwise comparisons for focal haplotype

pairs(emmeans(size_emmeans, ~ Focal_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

##### Social haplotype effect sizes

```{r}
# Now for social haplotype

pairs(emmeans(size_emmeans, ~ Social_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```


$~$


### Female reproductive output
* * *

To effectively accommodate zero-inflation, we modelled female offspring production using the `glmmTMB` package [@RN602]. This package allows us to fit hurdle models and zero-inflated models.

We analysed the number of offspring produced by females using a hurdle model with negative binomial errors. This approach allowed us to answer two questions: (1) did mtDNA affect the incidence of failing to produce any offspring? and (2) for females that produced at least one offspring, was the number of offspring produced affected by mtDNA?

The model:

_Maternal_total_offspring ~ Focal_haplotype * Social_haplotype + (1|Strain) + (1|Block)_

```{r female model}
female_hurdle_model <- glmmTMB(Maternal_total_offspring ~ Social_haplotype * Focal_haplotype + (1|Strain) + (1|Block), data = female_reproductive_output, family = list(family="truncated_nbinom1",link="log"), ziformula = ~., na.action = na.fail, REML = FALSE)
```

#### Model evaluation

**Table S8**: Evaluation of the female reproductive output model. All possible models were evaluated from the global model that included an interaction between focal haplotype and social haplotype and the random factors strain and block. As there was no clear top model, the final model was calculated via model averaging. The zero-inflated results relate to whether a female produced any offspring, while the conditional results relate to the number of offspring produced by fertile females.
```{r female dredge table}
# Compare all possible combinations of models (from the global model)

if(file.exists("female_dredge.rds")){ # If already done, just load the results
  female_dredge <- readRDS("female_dredge.rds")
} else {female_dredge <- dredge(female_hurdle_model)                  # If not already done, run all the models and save the results
lapply(c("female_dredge"), save_it)
}


female_table <- subset(female_dredge, delta < 6, recalc.weights = FALSE) %>% as.data.frame()

names(female_table)[names(female_table) == "cond((Int))"] <- "Conditional intercept"
names(female_table)[names(female_table) == "zi((Int))"] <- "Zero-inflated intercept"
names(female_table)[names(female_table) == "disp((Int))"] <- "Dispersion factor intercept"
names(female_table)[names(female_table) == "cond(Focal_haplotype)"] <- "Conditional (Focal haplotype)"
names(female_table)[names(female_table) == "cond(Social_haplotype)"] <- "Conditional (Social haplotype)"
names(female_table)[names(female_table) == "cond(Focal_haplotype:Social_haplotype)"] <- "Conditional (Focal haplotype x Social haplotype)"
names(female_table)[names(female_table) == "zi(Focal_haplotype)"] <- "Zero-inflated (Focal haplotype)"
names(female_table)[names(female_table) == "zi(Social_haplotype)"] <- "Zero-inflated (Social haplotype)"
names(female_table)[names(female_table) == "zi(Focal_haplotype:Social_haplotype)"] <- "Zero-inflated (Focal haplotype x Social haplotype)"
names(female_table)[names(female_table) == "df"] <- "Degrees of freedom"
names(female_table)[names(female_table) == "logLik"] <- "Log likelihood"
names(female_table)[names(female_table) == "AICc"] <- "AICc"
names(female_table)[names(female_table) == "delta"] <- "Delta"
names(female_table)[names(female_table) == "weight"] <- "Weight"

pander(female_table, split.cell = 40, split.table = Inf)

```

$~$


Relative variable importance for each of the predictors and interactions in the female reproductive output model set.

```{r, female RVI}

# present relative variable importance in a table 

sw(female_dredge) %>%
  as.data.frame() %>%
  pander(split.cell = 40, split.table = Inf, round = 3, col.names = "RVI")
```

$~$



#### Model averaging

Zi (zero-hurdle requirement) and conditional (after hurdle)  model coefficients, standard error and 95% confidence limits listed in **Table 1** are shown for the female offspring production averaged model. Bold rows indicate significant effects. 

```{r female model averaging}

# We need to create the top_survival_models object and average from that so that we can get mean estimates successfully using predict()

top_female_models <- get.models(female_dredge, subset = delta < 6)

female_avgm <- model.avg(top_female_models)

# extract useful info

Female_CIs <- confint(female_avgm) %>% as.data.frame()

Female_estimate <- coefTable(female_avgm) %>% as.data.frame()

Female_p_values <- summary(female_avgm)$coefmat.subset[, 5] %>% as.data.frame() %>% rename(p = ".")

Female_model_avg <- data.frame(Female_estimate, Female_CIs, Female_p_values) %>% select(Estimate, Std..Error,  X2.5.., X97.5.., p)

row.names(Female_model_avg) <- c("Conditional intercept", "Conditional focal haplotype: Brownsville", "Conditional focal haplotype: Dahomey", "Conditional focal haplotype: Israel", "Conditional focal haplotype: Sweden", "Zi intercept", "Zi social haplotype: Brownsville", "Zi social haplotype: Dahomey", "Zi social haplotype: Israel", "Zi social haplotype: Sweden", "Zi focal haplotype: Brownsville", "Zi focal haplotype: Dahomey", "Zi focal haplotype: Israel", "Zi focal haplotype: Sweden")


names(Female_model_avg)[names(Female_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Female_model_avg)[names(Female_model_avg) == "Std..Error"] <- "Standard Error"
names(Female_model_avg)[names(Female_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Female_model_avg)[names(Female_model_avg) == "X97.5.."] <- "97.5% Interval"

Female_model_avg %>%
  pander(split.cell = 40, split.table = Inf, emphasize.strong.rows = c(2, 5, 9), round = 3)

```

$~$


#### Comparison of focal and social haplotype effect sizes 

While our experiment was not designed to calculate estimates of conventional selection and social selection, we present the standardised effect size for the difference in mean fitness between haplotype pairs, for direct and indirect fitness effects. While our power is low when making these contrasts, the aim here is to illustrate that the size of the indirect effects on female reproductive output are of similar magnitudes to, or exceed the size of, focal haplotype effects.

##### Did the female produce offspring (hurdle component of the model) {.tabset}


###### Focal haplotype effect sizes


```{r}
# Fit a simplified version of the model without interactions that can be used with the emmeans() function. For the hurdle component of the model we simply fit a binary model with the response variable: did the female produce >= 1 offspring. This produces slightly different estimates from the full hurdle model but the effects sizes are extremely similar.

female_reproductive_output_zi <- female_reproductive_output %>% 
  mutate(produced_offspring = if_else(Maternal_total_offspring == 0, 0, 1))

female_emmeans_h <- glmmTMB(produced_offspring ~ Social_haplotype + Focal_haplotype + (1|Strain) + (1|Block), data = female_reproductive_output_zi, family = binomial, na.action = na.fail, REML = FALSE)

# Now create the pairwise comparisons for focal haplotype

pairs(emmeans(female_emmeans_h, ~ Focal_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

###### Social haplotype effect sizes

```{r}
# Now for social haplotype

pairs(emmeans(female_emmeans_h, ~ Social_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```


##### The number of offspring produced by fertile females (conditional component of the model) {.tabset}


###### Focal haplotype effect sizes

```{r}
# Fit a simplified version of the model without interactions that can be used with the emmeans() function. This model is reasonable as we detected no evidence for an interaction between any of our fixed effects in the above analysis.

female_emmeans <- glmmTMB(Maternal_total_offspring ~ Social_haplotype + Focal_haplotype + (1|Strain) + (1|Block), data = female_reproductive_output, family = list(family="truncated_nbinom1",link="log"), ziformula = ~., na.action = na.fail, REML = FALSE)

# Now create the pairwise comparisons for focal haplotype

pairs(emmeans(female_emmeans, ~ Focal_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

###### Social haplotype effect sizes

```{r}
# Now for social haplotype

pairs(emmeans(female_emmeans, ~ Social_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

$~$


#### Create Figure 1

```{r female figure, fig.width=11, fig.height=11}

# Plotting with model predictions

# predict.averaging does not return predictions for the conditional estimates (i.e. model coefficients averaged over models that contain the relevant predictor, rather than over the full specified subset). To predict mean estimates for each categorical variable, I can get these model averaged estimates by manually specifying the models I want to be averaged. These are used only for plotting.

# First average models that contain the predictor focal haplotype in the Zi formula. These were found by inspection of the top model list above.

focal_female_zi_models <- get.models(female_dredge, subset = "26")

# Note that only model "26' contains focal haplotype in the Zi formula. No averaging takes place and estimates are derived straight from this model. The conditional averaged estimates from the female_avgm object are identical to the estimates in model "26".

# fit model "26"

focal_zi_female_avg <- glmmTMB(Maternal_total_offspring ~ Focal_haplotype + (1|Strain) + (1|Block), data = female_reproductive_output, family = list(family="truncated_nbinom1",link="log"), ziformula = ~ Focal_haplotype + Social_haplotype + (1|Strain) + (1|Block), na.action = na.fail, REML = FALSE)


# Now average models that contain the social haplotype predictor in the Zi formula.

social_female_zi_models <- get.models(female_dredge, subset = c("18", "17", "26"))

social_zi_female_avg <- model.avg(social_female_zi_models)

# The conditional averaged estimates from the female_avgm object are identical to the zi social haplotype estimates from the "full model "social_zi_female_avg" object.

# Now average models that contain the focal haplotype predictor in the conditional formula.

focal_female_con_models <- get.models(female_dredge, subset = c("18", "2", "26"))

focal_con_female_avg <- model.avg(focal_female_con_models)

# Estimates match female_avg

# Make a new dataframe, for which we will derive predictions. It's the same as the old data, except that we set Focal haplotype, block and duplicate to the same value for all observations. The re.form = NA argument sets random effects to 0, meaning population means are calculated.
 
new_data <- female_reproductive_output %>%
  ungroup() %>%
  select(Focal_haplotype, Strain, Block) %>%
  mutate(Social_haplotype = "Barcelona", Strain = "Barcelona 1", Block = "1") %>% 
  distinct()

# First lets get predictions for the average number of offspring produced by females that produced at least one progeny, split by focal haplotype.

pred <- predict(focal_con_female_avg, se.fit = TRUE, type = "conditional", re.form = NA, new_data) %>%
  unlist() %>% 
  as.data.frame()

pred1 <- pred %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred2 <- pred %>% 
  slice(6:10) %>% 
  rename(SE = ".")
  
pred <- cbind(new_data, pred1, pred2) %>%
  mutate(Upper = mean_estimate + SE,
         Lower = mean_estimate - SE) %>%
  rename(Maternal_total_offspring = mean_estimate)

# Load the data for each individual female that produced offspring so that this can be plotted

female_cond_plot_data <- female_reproductive_output %>% 
  filter(Maternal_total_offspring != 0) %>%
  ungroup() %>% 
  select(Individual, Focal_haplotype, Maternal_total_offspring)

# Now lets plot these predictions

female_focal_cond_plot <- female_cond_plot_data %>%
  ggplot(aes(x = Focal_haplotype, y = Maternal_total_offspring, fill = Focal_haplotype, colour = Focal_haplotype)) +
  geom_quasirandom(data = female_cond_plot_data, width = 0.3, size = 2, alpha =  0.5, pch = 21, colour = 'grey26') +
  scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  geom_point(data = pred, aes(x = Focal_haplotype, y = Maternal_total_offspring), size = 3, colour='black') +
  geom_errorbar(data = pred, aes(x = Focal_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  labs(x = "Female mtDNA haplotype", y = "Number of offspring produced by females") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())

# Now lets get the Zi predictions for focal haplotype

pred_ZI <- predict(focal_zi_female_avg, se.fit = TRUE, type = "zprob", re.form = NA, new_data) %>%
  unlist() %>% 
  as.data.frame()

pred_ZI_1 <- pred_ZI %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_ZI_2 <- pred_ZI %>% 
  slice(6:10) %>% 
  rename(SE = ".")

pred_focal_ZI <- cbind(new_data, pred_ZI_1, pred_ZI_2) %>%
  transmute(Focal_haplotype, Strain, Block, Social_haplotype, mean_estimate  = 1 - mean_estimate, SE) %>% 
  mutate(Upper = mean_estimate + SE,
         Lower = mean_estimate - SE)
  

# Plot
  
female_focal_zi_plot <- pred_focal_ZI %>%
  ggplot(aes(x = Focal_haplotype, y = mean_estimate, fill = Focal_haplotype, colour = Focal_haplotype)) +
  geom_errorbar(aes(x = Focal_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  geom_point(aes(x = Focal_haplotype, y = mean_estimate), size = 4, pch =21, colour='grey26') +
  scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  labs(x = "Female mtDNA haplotype", y = "Proportion of females producing offspring") +
  ylim(0.4, 1) +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())

# Now create the newdata for social haplotype predictions

new_data_social <- female_reproductive_output %>%
  ungroup() %>%
  select(Social_haplotype, Strain, Block) %>%
  mutate(Focal_haplotype = "Barcelona", Strain = "Barcelona 1", Block = "1") %>% 
  distinct()

# Get zi social haplotype predictions

pred_social_ZI <- predict(social_zi_female_avg, se.fit = TRUE, type = "zprob", re.form = NA, new_data_social) %>%
  unlist() %>% 
  as.data.frame()

pred_ZI_social_1 <- pred_social_ZI %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_ZI_social_2 <- pred_social_ZI %>% 
  slice(6:10) %>% 
  rename(SE = ".")

pred_focal_ZI_social <- cbind(new_data_social, pred_ZI_social_1, pred_ZI_social_2) %>% 
  transmute(Social_haplotype, Strain, Block, Focal_haplotype, mean_estimate  = 1 - mean_estimate, SE) %>% 
  mutate(Upper = mean_estimate + SE,
         Lower = mean_estimate - SE)
  
  # Plot 
  
female_social_zi_plot <- pred_focal_ZI_social %>%
  ggplot(aes(x = Social_haplotype, y = mean_estimate, fill = Social_haplotype, colour = Social_haplotype)) +
  geom_errorbar(aes(x = Social_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  geom_point(aes(x = Social_haplotype, y = mean_estimate), size = 4, pch =21, colour='grey26') +
  scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  labs(x = "Male mtDNA haplotype", y = "Proportion of females producing offspring") +
  ylim(0.4, 1) +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())


# Lets calculate mean estimates from the raw data for the number of offspring produced by females split by social haplotype. We can't use model predictions here because social haplotype is not retained in the conditional part of the model 

female_reproductive_output_cond <- female_reproductive_output %>% 
  filter(Maternal_total_offspring != 0)

female_social_raw_cond <- female_reproductive_output_cond %>% 
  dplyr::group_by(Social_haplotype) %>%
  dplyr::summarise(Mean_offspring = sum(Maternal_total_offspring) / length(Maternal_total_offspring), Lower = (Mean_offspring - SE(Maternal_total_offspring)), Upper = (Mean_offspring + SE(Maternal_total_offspring)), n = n()) %>% 
  rename(Maternal_total_offspring = Mean_offspring)

female_social_cond_plot <- female_reproductive_output_cond %>%
  ggplot(aes(x = Social_haplotype, y = Maternal_total_offspring, fill = Social_haplotype, colour = Social_haplotype)) +
  geom_quasirandom(data = female_reproductive_output_cond, width = 0.3, size = 2, alpha =  0.5, pch = 21, colour = 'grey26') +
scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
geom_point(data = female_social_raw_cond, aes(x = Social_haplotype, y = Maternal_total_offspring), size = 3, colour='black') +
  geom_errorbar(data = female_social_raw_cond, aes(x = Social_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  labs(x = "Male mtDNA haplotype", y = "Number of offspring produced by females") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())


ggarrange(female_focal_zi_plot, female_social_zi_plot, female_focal_cond_plot, female_social_cond_plot, labels = c("a", "b", "c", "d"))
  
```

**Figure 1:** mtDNA directly and indirectly affects female fitness. Panels **a** and **b** show model predictions of the mean proportion of females that produced offspring (the zero-inflated or hurdle component of the model) across **a** female focal mtDNA haplotypes and **b** social male mtDNA haplotypes.  Panels **c** and **d** show the direct and indirect effect of mtDNA on the number of offspring produced by a female. Black points show model predictions of the mean for each haplotype in **c** and mean estimates from the raw data in **d**, while coloured points represent offspring produced by individual females. Model predictions were not calculated for **d** because social haplotype was not retained as a predictor for the conditional component of the averaged hurdle model. Error bars depict standard errors in all plots.


$~$


### Male reproductive fitness
* * *

Our measure of male fitness involves both pre- and post-copulatory competitive ability; that is we assess in one measure the combination of 1) the ability of a male to inseminate a female in the presence of another male and 2) the competitive ability of his sperm within females that have been inseminated by another male.

We analyse male fitness as the proportion of offspring produced by _mt_-strain males competing against a standard _bw_ male competitor. The data contains many 0 or 1 values - corresponding to a monopoly of female fertilisation by one of the males. To model this process we specify a beta-binomial distribution, which allows greater flexibility when modelling the distribution of the response. 

The Brownsville haplotype renders males sterile alongside the _w^1118^_ nuclear background and sub-fertile alongside all other tested backgrounds. In our experiment, we find that Brownsville males are able to produce offspring but to a very limited capacity. Due to this, our model is unable to produce reliable estimates when the interaction between focal and social haplotype is included. We do not include the interaction in the full model.

We include an additional random effect - MALE ID - in the model to account for repeated measures of each pair of focal and rival males.

_(Focal_male_offspring, bw_offspring) ~ Focal_haplotype + Social_haplotype + (1|Strain) + (1|Block) + (1|Male_ID)_ 

```{r male model}

response <- cbind(Male_fitness$Focal_male_offspring, Male_fitness$bw_male_offspring)

Male_fitness <- 
  Male_fitness %>% 
  rename(Male_ID = Individual)

male_model <- glmmTMB(response ~ Focal_haplotype + Social_haplotype + (1|Block) + (1|Strain) + (1|Male_ID), data = Male_fitness, family = "betabinomial", na.action = na.fail)

```

#### Model evaluation


**Table S9**: Evaluation of the male adult fitness model. All possible models were evaluated from the global model that included focal haplotype, social haplotype and the random factors strain, block and individual. As there was no clear top model, the final model was calculated via model averaging.

```{r male dredge table}

male_dredge <- dredge(male_model)

Male_table <- subset(male_dredge, delta < 6) %>% as.data.frame()


names(Male_table)[names(Male_table) == "(Intercept)"] <- "Intercept"
names(Male_table)[names(Male_table) == "Focal_haplotype"] <- "Focal haplotype"
names(Male_table)[names(Male_table) == "Social_haplotype"] <- "Social haplotype"
names(Male_table)[names(Male_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(Male_table)[names(Male_table) == "df"] <- "Degrees of freedom"
names(Male_table)[names(Male_table) == "logLik"] <- "Log likelihood"
names(Male_table)[names(Male_table) == "AICc"] <- "AICc"
names(Male_table)[names(Male_table) == "delta"] <- "Delta"
names(Male_table)[names(Male_table) == "weight"] <- "Weight"

pander(Male_table, split.cell = 40, split.table = Inf)

```

$~$


Relative variable importance for each of the predictors and interactions in the male reproductive fitness model set.

```{r, male RVI}

# present relative variable importance in a table 

sw(male_dredge) %>%
  as.data.frame() %>%
  pander(split.cell = 40, split.table = Inf, round = 3, col.names = "RVI")
```

$~$



#### Model averaging

Model coefficients, standard error and 95% confidence limits listed in **Table 2** are shown for the male adult fitness averaged model. Bold rows indicate significant effects. 

```{r male model averaging}

# Model average

top_male_models <- get.models(male_dredge, subset = delta < 6)

male_avgm <- model.avg(top_male_models)

# extract useful information

# summary(model.avg(male_binary_dredge, subset = delta < 6))

Male_CIs <- confint(male_avgm) %>% as.data.frame()

Male_estimate <- coefTable(male_avgm) %>% as.data.frame()

Male_p_values <- summary(male_avgm)$coefmat.subset[, 5] %>% as.data.frame() %>% rename(p = ".")

Male_model_avg <- data.frame(Male_estimate, Male_CIs, Male_p_values) %>% select(Estimate, Std..Error,  X2.5.., X97.5.., p)

row.names(Male_model_avg) <- c("Intercept", "Focal haplotype: Brownsville", "Focal haplotype: Dahomey", "Focal haplotype: Israel", "Focal haplotype: Sweden", "Social haplotype: Brownsville", "Social haplotype: Dahomey", "Social haplotype: Israel", "Social haplotype: Sweden")

names(Male_model_avg)[names(Male_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Male_model_avg)[names(Male_model_avg) == "Std..Error"] <- "Standard Error"
names(Male_model_avg)[names(Male_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Male_model_avg)[names(Male_model_avg) == "X97.5.."] <- "97.5% Interval"

pander(Male_model_avg, split.cell = 40, split.table = Inf, emphasize.strong.rows = 2, round = 3)

```

$~$


#### Comparison of focal and social haplotype effect sizes {.tabset}

While our experiment was not designed to calculate estimates of conventional selection and social selection, we present the standardised effect size for the difference in mean fitness between haplotype pairs, for direct and indirect fitness effects. While our power is low when making these contrasts, the aim here is to illustrate that the size of the direct effects on male reproductive competiitve ability are much larger than the indirect effects.

##### Focal haplotype effect sizes

```{r}
# We can use our original model

# Now create the pairwise comparisons for focal haplotype

pairs(emmeans(male_model, ~ Focal_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

##### Social haplotype effect sizes

```{r}
# Now for social haplotype

pairs(emmeans(male_model, ~ Social_haplotype, type = "response")) %>% 
  as_tibble() %>% 
  pander(split.cell = 40, split.table = Inf)

```

$~$


#### Create Figure 2

```{r male figure, fig.width= 8.5, fig.height= 6}

# predict.averaging does not return predictions for the conditional estimates (i.e. model coefficients averaged over models that contain the relevant predictor, rather than over the full specified subset). To predict mean estimates for each categorical variable, I can get these model averaged estimates by manually specifying the models I want to be avergaged. These are used only for plotting.

# First average models that contain the predictor focal haplotype. These were found by inspection of the top model list above.

focal_male_models <- get.models(male_dredge, subset = c("2", "4"))

focal_male_avg <- model.avg(focal_male_models)

# Note that the conditional averaged estimates from the male_avgm object are identical to the full averaged estimates for the focal_male_avg object for focal haplotype.

# Now average models that contain the social haplotype predictor.

social_male_models <- get.models(male_dredge, subset = c("4"))

# Note that there is only one model (the original full model) that contains social haplotype in the < 6 delta subset, so estimates are calculated directly from this model - no averaging occurs. The conditional averaged estimates from the male_avgm object are identical to the estimates from the full model.



# Focal new data

new_data_male <- Male_fitness %>%
  ungroup() %>%
  select(Focal_haplotype, Block, Strain, Male_ID) %>%
  mutate(Social_haplotype = "Barcelona", Block = "1", Strain = "Barcelona 1", Male_ID = "4") %>% 
  distinct() 


pred_male_focal <- predict(focal_male_avg, newdata = new_data_male, type = "response", se.fit = TRUE, re.form = NA) %>%
  unlist() %>% 
  as.data.frame()

pred_male_focal_1 <- pred_male_focal %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_male_focal_2 <- pred_male_focal %>% 
  slice(6:10) %>% 
  rename(SE = ".")
  
pred_focal_male <- cbind(new_data_male, pred_male_focal_1, pred_male_focal_2) %>% 
  rename(Proportion_focal = mean_estimate) %>% 
  mutate(Upper = Proportion_focal + SE,
         Lower = Proportion_focal - SE)

# Plot

Male_focal_plot <- Male_fitness %>%
  ggplot(aes(x = Focal_haplotype, y = Proportion_focal, fill = Focal_haplotype, colour = Focal_haplotype)) +
  geom_quasirandom(data = Male_fitness, width = 0.3, alpha =  0.3, pch = 21, colour = 'grey21', aes(size = Offspring_counted)) +
  scale_size_continuous(range = c(0.5, 6), labels = NULL, breaks = c(20, 40, 60, 80, 100, 120)) +
  scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  geom_point(data = pred_focal_male, aes(x = Focal_haplotype, y = Proportion_focal), size = 3, colour='black') +
  geom_errorbar(data = pred_focal_male, aes(x = Focal_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  labs(x = "Male mtDNA haplotype", y = "Proportion of offspring sired by focal male") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())


# Social new data

new_data_social_male <- Male_fitness %>%
  ungroup() %>%
  select(Social_haplotype, Block, Strain, Male_ID) %>%
  mutate(Focal_haplotype = "Barcelona", Block = "1", Strain = "Barcelona 1", Male_ID = "4") %>% 
  distinct()

# predict.averaging works over the full average rather than the conditional average that we present. I use a workaround where I create another model average object but only using the models in the < 6 delta subset that include social haplotype. Here only two models make the cut - the full model is the only one containing social haplotype as a predictor so no averaging is neccessary. Plug the full model into the predict function.

pred_male_social <- predict(male_model, newdata = new_data_social_male, type = "response", se.fit = TRUE, re.form = NA) %>%
  unlist() %>% 
  as.data.frame()

pred_male_social_1 <- pred_male_social %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_male_social_2 <- pred_male_social %>% 
  slice(6:10) %>% 
  rename(SE = ".")
  
pred_male_social <- cbind(new_data_social_male, pred_male_social_1, pred_male_social_2) %>% 
  rename(Proportion_focal = mean_estimate) %>% 
  mutate(Upper = Proportion_focal + SE,
         Lower = Proportion_focal - SE)
  

# Plot

Male_social_plot <- Male_fitness %>%
  ggplot(aes(x = Social_haplotype, y = Proportion_focal, fill = Social_haplotype, colour = Social_haplotype)) +
  geom_quasirandom(data = Male_fitness, width = 0.3, alpha =  0.3, pch = 21, colour = 'grey21', aes(size = Offspring_counted)) +
  scale_size_continuous(range = c(0.5, 6), labels = NULL, breaks = c(20, 40, 60, 80, 100, 120)) +
 scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  geom_point(data = pred_male_social, aes(x = Social_haplotype, y = Proportion_focal), size = 3, colour='black') +
  geom_errorbar(data = pred_male_social, aes(x = Social_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  labs(x = "Female mtDNA haplotype", y = "Proportion of offspring sired by focal male") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())

ggarrange(Male_focal_plot, Male_social_plot, labels = c("a", "b"))

```

**Figure 2**: The proportion of offspring produced by _mt_-strain males competing with standard _bw_ males. **a** shows the direct effect of mtDNA on male fitness. **b** shows the indirect genetic effect of female mtDNA on male fitness. Coloured points represent individual males, with larger points indicating a higher number of offspring produced in the vial (sired by either male). Black points show model predictions of the mean proportion of offspring sired by the _mt_-strain male, with associated standard errors.


$~$


# Raw data and reproducibility

### Table of raw data

For the purposes of completeness, transparency and data archiving, we include the raw data in this report.


**Table S10**: the raw data-set used in the present study, with NA values resulting from data collection mistakes removed (i.e. two females placed in competitive environment, no value recorded for whether the fly survived, flies that escaped during the experiment etc.).
```{r raw data}
kable(fitness_data %>% filter(!is.na(Survived)), "html") %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "800px")
```


$~$


Columns represent:

**Individual:** the focal fly being tested.

**Block:** the experiment was completed in six separate blocks, identified here 1-6.

**Strain:** which of the 10 combinations of haplotype and duplicate strain was the individual from?

**Dyad_ID:** this identifies the pipette tip environment that the individual developed in.

**Sex:** the sex of the focal individual.

**Focal_haplotype:** the mtDNA haplotype carried by the focal individual.

**Social_haplotype:** the mtDNA haplotype carried by the focal individual's competitor.

**Survived:** did the focal individual survive to adulthood (1) or die during larval development (0)?

**Dev_time:** the hours taken for the focal individual to progress from an egg to an adult. NA values indicate where individuals did not survive or development time could not be measured.

**Wing_length:** the length in mm of the focal individual's right wing.

**Maternal_female_offspring:** the number of adult female offspring the focal _mt_-strain female produced over a two day period.

**Maternal_male_offspring:** the number of adult male offspring the focal _mt_-strain female produced over a two day period.

**Maternal_total_offspring:** the total number of adult offspring the focal _mt_-strain female produced over a two day period.

**Paternal_focal_offspring:** the number of red-eye phenotype offspring sired by a _mt_-strain male in the adult male fitness assay.

**Paternal_bw_offspring:** the number of brown-eye phenotype offspring sired by a _bw_ competitor male in the adult male fitness assay.

**Proportion focal:** the proportion of offspring produced by the _mt_-strain male in the adult male fitness assay.


### R session information

This section provides information on the operating system and R packages attached during the production of this document, to allow easier replication of the analysis.

```{r session info}
sessionInfo() %>% pander
```


# References
