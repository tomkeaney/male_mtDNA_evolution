---
title: Kin selection subverts mitochondrial transmission bias and allows male mtDNA evolution
author: "Thomas Keaney, Heidi Wong, Damian Dowling, Theresa Jones, and Luke Holman"
bibliography: "supp_references.bib"
subtitle: Supplementary material
output:
  html_document:
    code_folding: hide
    depth: 1
    number_sections: no
    theme: yeti
    toc: yes
    toc_float: yes
    code_download: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning = FALSE, message = FALSE)
```

# Supplementary methods


Schematics for replacement of the unknown _Sxl-GFP_ nuclear background with the isogenic _w^1118^_ background

![**Figure S1**: Crossing scheme used to create a standard homozygous GFP-w line. Males from this line were crossed with females carrying a specific mitochondrial haplotype, to create experimental mitolines. These newly produced lines carried the mitochondrial haplotype of the female and were heterozygous for the Sxl-GFP construct. G1 = the first generation of the cross.](Crossing_scheme.png)


# Data analysis and supplementary results


Here we include all code used to run our analysis, our rationale behind the modelling approaches, and all remaining supplementary tables and figures.

#### Load packages, read in the data and create some helpful functions

**EDIT THE PACKAGE LIST WHEN HAPPY WITH THE ANALYSIS**

```{r packages data and functions}

# load relevant packages

library(lme4) # for the lmer and glmer mixed model functions
library(lmerTest) # Used to get p-values for lmer models using simulation. It over-writes lmer() with a new version, which gives p-values
library(glmmTMB) # for zero-inflated or hurdle glms
library(MuMIn) # for model selection and averaging
library(tidyverse) # data re-shaping, ggplot, stringr and more
library(ggridges) # for joy plots
library(ggpubr) # for the ggarrange function
library(ggbeeswarm) # violin plots with data points
library(ggResidpanel) # for model assumption plots
library(kableExtra) # nice tables that can scroll
library(pander) # more nice tables
library(groupdata2) # for assigning rows in data-frames to groups

# Read in data frame and add Dyad_ID column

all_data <- read.csv("mtDNA_larval_competition_data.csv") %>% 
  arrange(Individual) %>%
  group(n = 2, method = "greedy") %>% rename(Dyad_ID = .groups)

# helper function for saving large model objects and naming the file object.rds

save_it <- function(object){
  saveRDS(get(object), file = paste(object, ".rds", sep = ""))}

```


#### Data preparation for all responses

```{r data cleaning}

# Clean the dataset up for analysis

# Select the columns we're interested in and rename them

fitness_data <- dplyr::select(all_data, Individual, Block, Strain,  Dyad_ID, Sex, Focal.haplotype, Social.haplotype, Mortality, Development.time..hrs., Wing.size..mm., Female.offspring, Male.offspring, Total.female.assay, Total.red.all.vials, Total.bw.all.vials, Proportion.red.all.vials) %>% 
  
rename(Block = Block, Survived = Mortality, Focal_haplotype = Focal.haplotype, Social_haplotype = Social.haplotype, Dev_time = Development.time..hrs., Wing_length = Wing.size..mm., Maternal_female_offspring = Female.offspring, Maternal_male_offspring = Male.offspring, Maternal_total_offspring = Total.female.assay, Paternal_focal_offspring = Total.red.all.vials, Paternal_bw_offspring = Total.bw.all.vials, Proportion_focal = Proportion.red.all.vials)

# Define new levels for mortality to make renaming possible 

levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "NO")
levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "YES")

# Rename the mortality responses
# L means died as larva, P means died as pupae, N means did not die (i.e. eclosed as an adult)

fitness_data$Survived[fitness_data$Survived == 'L'] <- 'NO'
fitness_data$Survived[fitness_data$Survived == 'P'] <- 'NO'
fitness_data$Survived[fitness_data$Survived == 'N'] <- 'YES'

# Now that it makes sense change "YES" to 1 and "NO" to 0 so we can fit a binomial GLM.

levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "1")
levels(fitness_data$Survived) <- c(levels(fitness_data$Survived), "0")

fitness_data$Survived[fitness_data$Survived == "YES"] <- 1
fitness_data$Survived[fitness_data$Survived == "NO"] <- 0

# Make the factor numeric 

fitness_data$Survived <- as.numeric(as.character(fitness_data$Survived))


# Create specific datasets for each fitness trait

# Remove all rows that contain an NA value in the survival column. The NAs mean things like the GFP sorting did not work, or the vial was never set up due to a shortage of larvae. They are not meaningful data, and we remove them here.

survival <- fitness_data %>% filter(!is.na(Survived)) 
  
# Remove all rows that contain an NA value in the development time column. This instances represent flies where we failed to measure development time. 

larval_development <- fitness_data %>% filter(!is.na(Dev_time)) 

# Remove all rows that contain an NA value in the wing length column. Wing length was not measured in Blocks 1 and 2.

body_size <- fitness_data %>% filter(!is.na(Wing_length)) 

# Remove all rows that contain an NA value in the female reproductive output column (e.g. all the males), and where females did not survive to adulthood (coded as producing 0 offspring). 

female_reproductive_output <- fitness_data %>% filter(!is.na(Maternal_total_offspring), Survived == 1)


# Male adult fitness

# First remove females from the dataset.

Male_fitness <- fitness_data %>% filter(!is.na(Paternal_focal_offspring)) 

# Create an offspring counted column so that the data is correctly formatted for a binomial success-failure model.

Male_fitness$Offspring_counted <- Male_fitness$Paternal_focal_offspring + Male_fitness$Paternal_bw_offspring

# Now lets remove vials where the female produced 0 offspring (this includes trials where the male died in development), as we cannot determine paternity from these vials. The tidy up the dataframe by removing unneccessary columns

Male_fitness <- Male_fitness %>% filter(!(Offspring_counted == 0)) %>% 
  select(-Maternal_female_offspring, -Maternal_male_offspring, -Maternal_total_offspring) %>% 
  rename(Focal_male_offspring = Paternal_focal_offspring, bw_male_offspring = Paternal_bw_offspring)

```


## Modelling approach

We analysed the data using generalised linear mixed models in the `lmer` package for R.

**Fixed effects**

For the analysis of fitness traits expressed in both sexes (survival, development time and body size), we are interested in the effect of an individualâ€™s focal mtDNA, the mtDNA of a social competitor and the effect of sex on fitness. To identify these potential effects each model contained the following fixed effects and the three-way interaction between these variables:

Focal haplotype: the mtDNA haplotype that an individual carries.

Social haplotype: the mtDNA haplotype carried by a social partner during larval development.

Sex: is the focal individual female or male? The social partner's sex was always opposite to that of the focal individual.

**Random effects**

Duplicate strain: Each haplotype has been introgressed alongside the _w^1118^_ nuclear background in two independent duplicates, creating 10 total strains. Within each block we ran multiple replicates that were made up of flies from the first set of strains (i.e. Barcelona 1, Brownsville 1 etc.), while the other half used only flies from strains denoted '2'. This random effect accounts for any residual differences in their nuclear genome, epigenome, microbiome or vial environment that may have arisen between duplicates.

Block: accounts for differences in the response variable between experimental blocks (e.g. to variance in temperature or composition of the fly food). In our experiment a block contained multiple replicates and a replicate was made up of 25 different cells each housing a pair of larvae.

Dyad ID: accounts for differences in the quality of the larval environment between pairs of larvae. For example, the moisture content of the food varied between pipette tips, despite our best efforts to keep this variable constant.  

**Model evaluation**

Each model was evaluated and ranked by AICc values using the `dredge` function, from the `Mumin` package. There was rarely a single model that was unequivocally the best fit to the data, so we conducted model averaging for the set of models where delta was < 6, as suggested by Symonds and Moussalli [-@RN455]. The present study is a planned experiment to measure the effect of mtDNA on fitness, so we derived model estimates from the conditional model averages.


## Larval fitness measures


### Egg to adult viability analysis
* * *

We fit a glm with binomial errors to model survival

The model:

_Survival ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID)_

```{r survival model}

# Fit the global model

survival_model <- lme4::glmer(Survived ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), data = survival, family = "binomial", control = glmerControl(optimizer = "Nelder_Mead", optCtrl=list(maxfun=100000)), na.action = na.fail)

```

#### Model evaluation

**Table S1**: Evaluation of the survivorship model. All possible models were evaluated from the global model that included a three-way interaction between Focal haplotype, Social haplotype and Sex, as well as the random factors duplicate Strain, Block and Dyad ID. As there was no clear top model, the final model was calculated via model averaging.
```{r survival dredge table}

# Compare all possible combinations of models (from the global model)

if(file.exists("survival_dredge.rds")){ # If already done, just load the results
  survival_dredge <- readRDS("survival_dredge.rds")
} else {survival_dredge <- dredge(survival_model) # If not already done, run all the models and save the results
lapply(c("survival_dredge"), save_it)
}


survival_table <- subset(survival_dredge, delta < 6, recalc.weights = FALSE) %>% as.data.frame()

names(survival_table)[names(survival_table) == "(Intercept)"] <- "Intercept"
names(survival_table)[names(survival_table) == "Focal_haplotype"] <- "Focal haplotype"
names(survival_table)[names(survival_table) == "Sex"] <- "Sex"
names(survival_table)[names(survival_table) == "Social_haplotype"] <- "Social haplotype"
names(survival_table)[names(survival_table) == "Focal_haplotype:Sex"] <- "Focal haplotype x Sex"
names(survival_table)[names(survival_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(survival_table)[names(survival_table) == "Sex:Social_haplotype"] <- "Social haplotype x Sex"
names(survival_table)[names(survival_table) == "Focal_haplotype:Sex:Social_haplotype"] <- "Focal haplotype x Social haplotype x Sex"
names(survival_table)[names(survival_table) == "df"] <- "Degrees of freedom"
names(survival_table)[names(survival_table) == "logLik"] <- "Log likelihood"
names(survival_table)[names(survival_table) == "AICc"] <- "AICc"
names(survival_table)[names(survival_table) == "delta"] <- "Delta"
names(survival_table)[names(survival_table) == "weight"] <- "Weight"

pander(survival_table, split.cell = 40, split.table = Inf)
```

#### Model averaging


Conditional model coefficients, standard error and 95% confidence limits listed in **Table 1** are shown for the survivorship to adulthood averaged model. Bold rows indicate significant effects.

```{r survival model averaging}

# Model average

# We need to create the top_survival_models object and average from that so that we can get mean estimates successfully using predict(), fitted() or eemeans()

top_survival_models <- get.models(survival_dredge, subset = delta < 6)

survival_avgm <- model.avg(top_survival_models)


# extract useful information

RVI_survival <- MuMIn::sw(survival_dredge)

# average the models with delta < 6

survival_CIs <- confint(model.avg(survival_dredge, subset = delta < 6)) %>% as.data.frame()

survival_estimate <- coefTable(model.avg(survival_dredge, subset = delta < 6)) %>% as.data.frame()

survival_model_avg <- data.frame(survival_estimate, survival_CIs) %>% select(Estimate, Std..Error,  X2.5.., X97.5..)

row.names(survival_model_avg) <- c("Intercept", "Sex: Male", "Focal haplotype: Brownsville", "Focal haplotype: Dahomey", "Focal haplotype: Israel", "Focal haplotype: Sweden", "Social haplotype: Brownsville", "Social haplotype: Dahomey", "Social haplotype: Israel", "Social haplotype: Sweden")

names(survival_model_avg)[names(survival_model_avg) == "Estimate"] <- "Conditional average estimate"
names(survival_model_avg)[names(survival_model_avg) == "Std..Error"] <- "Standard Error"
names(survival_model_avg)[names(survival_model_avg) == "X2.5.."] <- "2.5% Interval"
names(survival_model_avg)[names(survival_model_avg) == "X97.5.."] <- "97.5% Interval"


pander(survival_model_avg, split.cell = 40, split.table = Inf, round = 3)

# The full average provides a parameter average across all models considered, including ones where the parameter coefficient is set to 0. The conditional average reports coefficents for only the models where the parameter is included.

```

### Development time analysis
* * *

```{r dev time density plot}
(
density_development_plot <- ggplot(larval_development)+
  stat_density_ridges(aes(x=Dev_time, y = NA, fill = Sex), alpha = 0.7, scale = 12, position = position_nudge(y = -0.5), show.legend = T) +
  geom_vline(xintercept = 238, linetype = 2) +
  geom_vline(xintercept = 262, linetype = 2) +
  geom_vline(xintercept = 286, linetype = 2) +
  xlab("Egg-to-adult development time (hours)") +
  ylab("Kernel density estimate") +
  theme_bw() +
  scale_fill_manual(values = c("F" = "#ca562c", "M" = "#008080"), labels = c("Female", "Male")) +
  scale_x_continuous(limits = c(220, 310), breaks = c(220, 230, 240, 250, 260, 270, 280, 290, 300, 310)) +
  scale_y_discrete(expand = c(.0,0.0))+
  theme(panel.spacing = unit(0.1, "lines"),
        text = element_text(size=16),
        panel.border= element_blank(),
        axis.line=element_line(), 
        panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.title.x = element_text(hjust = 0.5, size = 14))
)


```

**Figure S2**: The distribution of egg-to-adult development time, split by sex. Dashed lines indicate when lights were turned each morning and highlight the relationship between light and eclosion.

The response variable has a trimodal distribution, that can be potentially explained by the lab's artificial day-night cycle. When the lights turn on at 7am, eclosion is stimulated.

The model:

_Dev_time ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID)_

```{r dev time model}

# Fit the linear model

linear_dev_model <- lmer(Dev_time ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), larval_development, na.action = na.fail, REML = FALSE)

```

Lets have a look at model diagnostics

```{r dev time diagnostic plot}
resid_panel(linear_dev_model)
```

The data is trimodal and the residuals vs fitted plot indicates that the mean and variance are weakly positively correlated. The Q-Q Plot shows that points fall off at the extremes, but generally conform to a linear pattern. Linear models are somewhat robust against slightly non-normal data so we proceed with the analysis.

#### Model evaluation

**Table S2**: Evaluation of the development time model. All possible models were evaluated from the global model that included a three-way interaction between Focal haplotype, Social haplotype and Sex as well as the random factors Strain and Block.  As there was no clear top model, the final model was calculated via model averaging.
```{r dev time dredge table}
# Use dredge to compare all possible models derived from the global model

Dev_time_linear_dredge <- dredge(linear_dev_model)

development_table <- subset(Dev_time_linear_dredge, delta < 6, recalc.weights = FALSE)  %>% as.data.frame()

names(development_table)[names(development_table) == "(Intercept)"] <- "Intercept"
names(development_table)[names(development_table) == "Focal_haplotype"] <- "Focal haplotype"
names(development_table)[names(development_table) == "Social_haplotype"] <- "Social haplotype"
names(development_table)[names(development_table) == "Focal_haplotype:Sex"] <- "Focal haplotype x Sex"
names(development_table)[names(development_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(development_table)[names(development_table) == "Sex:Social_haplotype"] <- "Social haplotype x Sex"
names(development_table)[names(development_table) == "Focal_haplotype:Sex:Social_haplotype"] <- "Focal haplotype x Social haplotype x Sex"
names(development_table)[names(development_table) == "df"] <- "Degrees of freedom"
names(development_table)[names(development_table) == "logLik"] <- "Log likelihood"
names(development_table)[names(development_table) == "AICc"] <- "AICc"
names(development_table)[names(development_table) == "delta"] <- "Delta"
names(development_table)[names(development_table) == "weight"] <- "Weight"

pander(development_table, split.cell = 40, split.table = Inf)

```

#### Model averaging

Conditional model coefficients, standard error and 95% confidence limits listed in **Table 2** are shown for the egg-to-adult development time averaged model. Bold rows indicate significant effects.

```{r dev time model averaging}

# first get the RVI for each predictor

RVI_dev <- MuMIn::sw(Dev_time_linear_dredge)

# Model averaging

Dev_time_avg <- (model.avg(Dev_time_linear_dredge, subset = delta < 6))

Dev_CIs <- confint(model.avg(Dev_time_linear_dredge, subset = delta < 6)) %>% as.data.frame()

Dev_estimate <- coefTable(model.avg(Dev_time_linear_dredge, subset = delta < 6)) %>% as.data.frame()

Dev_model_avg <- data.frame(Dev_estimate, Dev_CIs) %>% select(Estimate, Std..Error,  X2.5.., X97.5..)

row.names(Dev_model_avg) <- c("Intercept", "Sex: Male", "Focal haplotype: Brownsville", "Focal haplotype: Dahomey", "Focal haplotype: Israel", "Focal haplotype: Sweden", "Social haplotype: Brownsville", "Social haplotype: Dahomey", "Social haplotype: Israel", "Social haplotype: Sweden")

names(Dev_model_avg)[names(Dev_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Dev_model_avg)[names(Dev_model_avg) == "Std..Error"] <- "Standard Error"
names(Dev_model_avg)[names(Dev_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Dev_model_avg)[names(Dev_model_avg) == "X97.5.."] <- "97.5% Interval"


pander(Dev_model_avg, split.cell = 40, split.table = Inf, emphasize.strong.rows = 2, round = 3)

```


## Adult fitness measures


### Body size analysis
* * *

We use wing length as a proxy for adult body size.


It is distributed normally, so we fit a linear mixed model.

The model:

_Wing_length ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID)_


```{r size model}

body_size_model <- lmer(Wing_length ~ Focal_haplotype * Social_haplotype * Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), body_size, na.action = na.fail, REML = FALSE)

```



```{r size diagnostics,include=FALSE}

# Lets have a look at model diagnostics

resid_panel(body_size_model)
```

#### Model evaluation

**Table S3**: Evaluation of the wing length model. All possible models were evaluated from the global model that included a three-way interaction between focal haplotype, social haplotype and sex, as well as the random factors Duplicate strain, Block and Dyad ID. There was a clear top model; coefficients are displayed in Table S4.
```{r size dredge table}

# Compare all possible combinations of models (from the global model)

body_size_dredge <- dredge(body_size_model)

size_table <- subset(body_size_dredge, delta < 6, recalc.weights = FALSE) %>% as.data.frame()


names(size_table)[names(size_table) == "(Intercept)"] <- "Intercept"
names(size_table)[names(size_table) == "Focal_haplotype"] <- "Focal haplotype"
names(size_table)[names(size_table) == "Sex"] <- "Sex"
names(size_table)[names(size_table) == "Social_haplotype"] <- "Social haplotype"
names(size_table)[names(size_table) == "Focal_haplotype:Sex"] <- "Focal haplotype x Sex"
names(size_table)[names(size_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(size_table)[names(size_table) == "Sex:Social_haplotype"] <- "Social haplotype x Sex"
names(size_table)[names(size_table) == "Focal_haplotype:Sex:Social_haplotype"] <- "Focal haplotype x Social haplotype x Sex"
names(size_table)[names(size_table) == "df"] <- "Degrees of freedom"
names(size_table)[names(size_table) == "logLik"] <- "Log likelihood"
names(size_table)[names(size_table) == "AICc"] <- "AICc"
names(size_table)[names(size_table) == "delta"] <- "Delta"
names(size_table)[names(size_table) == "weight"] <- "Weight"

pander(size_table, split.cell = 40, split.table = Inf)

```

#### Best fitting model

There is a clear top model; model avergaing is not required.

Model coefficients, standard error and 95% confidence limits listed in **Table 3** are shown are shown for the wing length top model. Bold rows indicate significant effects.

```{r size best model}

# first get the RVI for each predictor

RVI_size <- MuMIn::sw(body_size_dredge)


# Fit the top model

body_size_model_final <- lmer(Wing_length ~ Sex + (1|Strain) + (1|Block) + (1|Dyad_ID), body_size, na.action = na.fail, REML = FALSE)

Size_CIs <- confint(body_size_model_final) %>%
  as.data.frame() %>% 
  slice(5:6)

Size_estimate <- coefTable(body_size_model_final) %>% as.data.frame()

Size_model_avg <- data.frame(Size_estimate, Size_CIs) %>% select(Estimate, Std..Error,  X2.5.., X97.5..)

row.names(Size_model_avg) <- c("Intercept", "Sex: Male")

names(Size_model_avg)[names(Size_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Size_model_avg)[names(Size_model_avg) == "Std..Error"] <- "Standard Error"
names(Size_model_avg)[names(Size_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Size_model_avg)[names(Size_model_avg) == "X97.5.."] <- "97.5% Interval"

pander(Size_model_avg, split.cell = 40, split.table = Inf, emphasize.strong.rows = (2), round = 3)

```


### Female reproductive output
* * *

To effectively accommodate zero-inflation, we modelled female offspring production using the `glmmTMB` package [@RN602]. This package allows us to fit hurdle models and zero-inflated models.

Hurdle models treat zero-count and nonzero outcomes as two completely separate categories, while zero-inflated models treat zero-count outcomes as a mixture of structural and sampling zeros.

We analysed the number of offspring produced by females using a hurdle model with negative binomial errors. This approach allowed us to answer two questions: (1) did mtDNA and/or competition affect the incidence of failing to produce any offspring? and (2) for females that produced at least one offspring, was the number of offspring produced affected by mtDNA/competition?

The model:

_Maternal_total_offspring ~ Focal_haplotype * Social_haplotype + (1|Strain) + (1|Block)_

```{r female model}
female_hurdle_model <- glmmTMB(Maternal_total_offspring ~ Social_haplotype * Focal_haplotype + (1|Strain) + (1|Block), data = female_reproductive_output, family = list(family="truncated_nbinom1",link="log"), ziformula = ~., na.action = na.fail, REML = FALSE)
```

#### Model evaluation

**Table S4**: Evaluation of the female reproductive output model. All possible models were evaluated from the global model that included an interaction between Focal haplotype and Social haplotype and the random factors Strain and Block. As there was no clear top model, the final model was calculated via model averaging. The zero-inflated results correspond to question (1), while the conditional results correspond to question (2) above.
```{r female dredge table}
# Compare all possible combinations of models (from the global model)

if(file.exists("female_dredge.rds")){ # If already done, just load the results
  female_dredge <- readRDS("female_dredge.rds")
} else {female_dredge <- dredge(female_hurdle_model)                  # If not already done, run all the models and save the results
lapply(c("female_dredge"), save_it)
}


female_table <- subset(female_dredge, delta < 6, recalc.weights = FALSE) %>% as.data.frame()

names(female_table)[names(female_table) == "cond((Int))"] <- "Conditional intercept"
names(female_table)[names(female_table) == "zi((Int))"] <- "Zero-inflated intercept"
names(female_table)[names(female_table) == "disp((Int))"] <- "Dispersion factor intercept"
names(female_table)[names(female_table) == "cond(Focal_haplotype)"] <- "Conditional (Focal haplotype)"
names(female_table)[names(female_table) == "cond(Social_haplotype)"] <- "Conditional (Social haplotype)"
names(female_table)[names(female_table) == "cond(Focal_haplotype:Social_haplotype)"] <- "Conditional (Focal haplotype x Social haplotype)"
names(female_table)[names(female_table) == "zi(Focal_haplotype)"] <- "Zero-inflated (Focal haplotype)"
names(female_table)[names(female_table) == "zi(Social_haplotype)"] <- "Zero-inflated (Social haplotype)"
names(female_table)[names(female_table) == "zi(Focal_haplotype:Social_haplotype)"] <- "Zero-inflated (Focal haplotype x Social haplotype)"
names(female_table)[names(female_table) == "df"] <- "Degrees of freedom"
names(female_table)[names(female_table) == "logLik"] <- "Log likelihood"
names(female_table)[names(female_table) == "AICc"] <- "AICc"
names(female_table)[names(female_table) == "delta"] <- "Delta"
names(female_table)[names(female_table) == "weight"] <- "Weight"

pander(female_table, split.cell = 40, split.table = Inf)

```

#### Model averaging

Zi (zero-hurdle requirement) and conditional (after hurdle)  model coefficients, standard error and 95% confidence limits listed in **Table 4** are shown for the female offspring production averaged model. Bold rows indicate significant effects. 

```{r female model averaging}

# We need to create the top_survival_models object and average from that so that we can get mean estimates successfully using predict()

top_female_models <- get.models(female_dredge, subset = delta < 6)

female_avgm <- model.avg(top_female_models)

# extract useful info

RVI_female <- MuMIn::sw(female_dredge)

Female_CIs <- confint(model.avg(female_dredge, subset = delta < 6)) %>% as.data.frame()

Female_estimate <- coefTable(model.avg(female_dredge, subset = delta < 6)) %>% as.data.frame()

Female_model_avg <- data.frame(Female_estimate, Female_CIs) %>% select(Estimate, Std..Error,  X2.5.., X97.5..)

row.names(Female_model_avg) <- c("Conditional intercept", "Conditional focal haplotype: Brownsville", "Conditional focal haplotype: Dahomey", "Conditional focal haplotype: Israel", "Conditional focal haplotype: Sweden", "Zi intercept", "Zi social haplotype: Brownsville", "Zi social haplotype: Dahomey", "Zi social haplotype: Israel", "Zi social haplotype: Sweden", "Zi focal haplotype: Brownsville", "Zi focal haplotype: Dahomey", "Zi focal haplotype: Israel", "Zi focal haplotype: Sweden")


names(Female_model_avg)[names(Female_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Female_model_avg)[names(Female_model_avg) == "Std..Error"] <- "Standard Error"
names(Female_model_avg)[names(Female_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Female_model_avg)[names(Female_model_avg) == "X97.5.."] <- "97.5% Interval"

Female_model_avg %>%
  pander(split.cell = 40, split.table = Inf, emphasize.strong.rows = c(2, 5, 9), round = 3)

```


```{r female figure, fig.width=11, fig.height=8.5}

# Plotting with model predictions

# predict.averaging does not return predictions for the conditional estimates (i.e. model coefficients averaged over models that contain the relevant predictor, rather than over the full specified subset). To predict mean estimates for each categorical variable, I can get these model averaged estimates by manually specifying the models I want to be avergaged. These are used only for plotting.

# First average models that contain the predictor focal haplotype in the Zi formual. These were found by inspection of the top model list above.

focal_female_zi_models <- get.models(female_dredge, subset = "26")

# Note that only model "26' contains focal haplotype in the Zi formula. No averaging takes place and estimates are derived straight from this model. The conditional averaged estimates from the female_avgm object are identical to the estimates in model "26".

# fit model "26"

focal_zi_female_avg <- glmmTMB(Maternal_total_offspring ~ Focal_haplotype + (1|Strain) + (1|Block), data = female_reproductive_output, family = list(family="truncated_nbinom1",link="log"), ziformula = ~ Focal_haplotype + Social_haplotype + (1|Strain) + (1|Block), na.action = na.fail, REML = FALSE)


# Now average models that contain the social haplotype predictor in the Zi formula.

social_female_zi_models <- get.models(female_dredge, subset = c("18", "17", "26"))

social_zi_female_avg <- model.avg(social_female_zi_models)

# The conditional averaged estimates from the female_avgm object are identical to the zi social haplotype estimates from the "full model "social_zi_female_avg" object.

# Now average models that contain the focal haplotype predictor in the conditional formula.

focal_female_con_models <- get.models(female_dredge, subset = c("18", "2", "26"))

focal_con_female_avg <- model.avg(focal_female_con_models)

# Estimates match female_avg

# Make a new dataframe, for which we will derive predictions. It's the same as the old data, except that we set Focal haplotype, block and duplicate to the same value for all observations. The re.form = NA argument sets random effects to 0, meaning population means are calculated.
 
new_data <- female_reproductive_output %>%
  ungroup() %>%
  select(Focal_haplotype, Strain, Block) %>%
  mutate(Social_haplotype = "Barcelona", Strain = "Barcelona 1", Block = "1") %>% 
  distinct()

# First lets get predictions for the average number of offspring produced by females that produced at least one progeny, split by focal haplotype.

pred <- predict(focal_con_female_avg, se.fit = TRUE, type = "conditional", re.form = NA, new_data) %>%
  unlist() %>% 
  as.data.frame()

pred1 <- pred %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred2 <- pred %>% 
  slice(6:10) %>% 
  rename(SE = ".")
  
pred <- cbind(new_data, pred1, pred2) %>%
  mutate(Upper = mean_estimate + SE,
         Lower = mean_estimate - SE) %>%
  rename(Maternal_total_offspring = mean_estimate)

# Load the data for each individual female that produced offspring so that this can be plotted

female_cond_plot_data <- female_reproductive_output %>% 
  filter(Maternal_total_offspring != 0) %>%
  ungroup() %>% 
  select(Individual, Focal_haplotype, Maternal_total_offspring)

# Now lets plot these predictions

female_focal_cond_plot <- female_cond_plot_data %>%
  ggplot(aes(x = Focal_haplotype, y = Maternal_total_offspring, fill = Focal_haplotype, colour = Focal_haplotype)) +
  geom_quasirandom(data = female_cond_plot_data, width = 0.3, size = 2, alpha =  0.5, pch = 21, colour = 'grey26') +
scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
geom_point(data = pred, aes(x = Focal_haplotype, y = Maternal_total_offspring), size = 3, colour='black') +
  geom_errorbar(data = pred, aes(x = Focal_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  labs(x = "Female mtDNA haplotype", y = "Number of offspring produced by females") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())

# Now lets get the Zi predictions for focal haplotype

pred_ZI <- predict(focal_zi_female_avg, se.fit = TRUE, type = "zprob", re.form = NA, new_data) %>%
  unlist() %>% 
  as.data.frame()

pred_ZI_1 <- pred_ZI %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_ZI_2 <- pred_ZI %>% 
  slice(6:10) %>% 
  rename(SE = ".")

pred_focal_ZI <- cbind(new_data, pred_ZI_1, pred_ZI_2) %>%
  transmute(Focal_haplotype, Strain, Block, Social_haplotype, mean_estimate  = 1 - mean_estimate, SE) %>% 
  mutate(Upper = mean_estimate + SE,
         Lower = mean_estimate - SE)
  
#rename(Maternal_total_offspring = mean_estimate)


# Plot
  
female_focal_zi_plot <- pred_focal_ZI %>%
  ggplot(aes(x = Focal_haplotype, y = mean_estimate, fill = Focal_haplotype, colour = Focal_haplotype)) +
  geom_errorbar(aes(x = Focal_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  geom_point(aes(x = Focal_haplotype, y = mean_estimate), size = 4, pch =21, colour='grey26', fill = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  labs(x = "Female mtDNA haplotype", y = "Proportion of females producing offspring") +
  ylim(0.4, 1) +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())
  

# Now create the newdata for social haplotype predictions

new_data_social <- female_reproductive_output %>%
  ungroup() %>%
  select(Social_haplotype, Strain, Block) %>%
  mutate(Focal_haplotype = "Barcelona", Strain = "Barcelona 1", Block = "1") %>% 
  distinct()

# Get zi social haplotype predictions

pred_social_ZI <- predict(social_zi_female_avg, se.fit = TRUE, type = "zprob", re.form = NA, new_data_social) %>%
  unlist() %>% 
  as.data.frame()

pred_ZI_social_1 <- pred_social_ZI %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_ZI_social_2 <- pred_social_ZI %>% 
  slice(6:10) %>% 
  rename(SE = ".")

pred_focal_ZI_social <- cbind(new_data_social, pred_ZI_social_1, pred_ZI_social_2) %>% 
  transmute(Social_haplotype, Strain, Block, Focal_haplotype, mean_estimate  = 1 - mean_estimate, SE) %>% 
  mutate(Upper = mean_estimate + SE,
         Lower = mean_estimate - SE)
  
  # Plot 
  
female_social_zi_plot <- pred_focal_ZI_social %>%
  ggplot(aes(x = Social_haplotype, y = mean_estimate, fill = Social_haplotype, colour = Social_haplotype)) +
  geom_errorbar(aes(x = Social_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  geom_point(aes(x = Social_haplotype, y = mean_estimate), size = 4, pch =21, colour='grey26', fill = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  labs(x = "Male mtDNA haplotype", y = "Proportion of females producing offspring") +
  ylim(0.4, 1) +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())

ggarrange(female_focal_zi_plot, female_social_zi_plot, female_focal_cond_plot, labels = c("a", "b", "c"))
  
```

**Figure 1:** mtDNA directly and indirectly affects female fitness. Panels **a** and **b** show model predictions of the mean proportion of females that produced offspring (the zero-inflated or hurdle component of the model) across **a** female focal haplotypes and **b** social male haplotypes. Error bars depict standard errors. Panel **c** shows the direct effect of mtDNA on the number of offspring produced by a female. Black points show model predictions of the mean with standard error for each haplotype, while coloured points represent offspring produced by individual females.


### Male adult fitness
* * *

Our measure of male fitness involves both pre- and post-copulatory competitive ability; that is we assess in one measure the combination of 1) the ability of a male to inseminate a female in the presence of another male and 2) the competitive ability of his sperm within females that have been inseminated by another male. Interestingly, the data contains many 0 or 1 values - corresponding to a monopoly of female fertilisation by one of the males. *SOMETHING ABOUT THE BETA BINOMIAL DISTRIBUTION *

We analyse male fitness as the proportion of offspring produced by mitochondrial strain males competing against a standard _bw_ male competitor. 

The Brownsville haplotype renders males sterile alongside the _w^1118^_ nuclear background and sub-fertile alongside all other tested backgrounds. In our experiment, we find that Brownsville males are able to produce offspring but to a very limited capacity. Due to this, our model is unable to produce reliable estimates when the interaction between focal and social haplotype is included. We do not include the interaction in the full model.

_(Focal_male_offspring, bw_offspring) ~ Focal_haplotype + Social_haplotype + (1|Strain) + (1|Block) + (1|Individual)_ 

```{r male model}

response <- cbind(Male_fitness$Focal_male_offspring, Male_fitness$bw_male_offspring)

male_binary_model <- glmmTMB(response ~ Focal_haplotype + Social_haplotype + (1|Block) + (1|Strain) + (1|Individual), data = Male_fitness, family = "betabinomial", na.action = na.fail)

```

#### Model evaluation


**Table S5**: Evaluation of the male adult fitness model. All possible models were evaluated from the global model that included an interaction between focal haplotype and social haplotype and the random factors Strain, Block and Individual. As there was no clear top model, the final model was calculated via model averaging.
```{r male dredge table}

male_dredge <- dredge(male_binary_model)

Male_table <- subset(male_dredge, delta < 6) %>% as.data.frame()


names(Male_table)[names(Male_table) == "(Intercept)"] <- "Intercept"
names(Male_table)[names(Male_table) == "Focal_haplotype"] <- "Focal haplotype"
names(Male_table)[names(Male_table) == "Social_haplotype"] <- "Social haplotype"
names(Male_table)[names(Male_table) == "Focal_haplotype:Social_haplotype"] <- "Focal haplotype x Social haplotype"
names(Male_table)[names(Male_table) == "df"] <- "Degrees of freedom"
names(Male_table)[names(Male_table) == "logLik"] <- "Log likelihood"
names(Male_table)[names(Male_table) == "AICc"] <- "AICc"
names(Male_table)[names(Male_table) == "delta"] <- "Delta"
names(Male_table)[names(Male_table) == "weight"] <- "Weight"

pander(Male_table, split.cell = 40, split.table = Inf)

```


#### Model averaging

Model coefficients, standard error and 95% confidence limits listed in **Table 5** are shown for the male adult fitness averaged model. Bold rows indicate significant effects. 

```{r male model averaging}

# Model average

top_male_models <- get.models(male_dredge, subset = delta < 6)

male_avgm <- model.avg(top_male_models)

# extract useful information

RVI_male <- MuMIn::sw(male_dredge)


# summary(model.avg(male_binary_dredge, subset = delta < 6))

Male_CIs <- confint(model.avg(male_dredge, subset = delta < 6)) %>% as.data.frame()

Male_estimate <- coefTable(model.avg(male_dredge, subset = delta < 6)) %>% as.data.frame()

Male_model_avg <- data.frame(Male_estimate, Male_CIs) %>% select(Estimate, Std..Error,  X2.5.., X97.5..)

row.names(Male_model_avg) <- c("Intercept", "Focal haplotype: Brownsville", "Focal haplotype: Dahomey", "Focal haplotype: Israel", "Focal haplotype: Sweden", "Social haplotype: Brownsville", "Social haplotype: Dahomey", "Social haplotype: Israel", "Social haplotype: Sweden")

names(Male_model_avg)[names(Male_model_avg) == "Estimate"] <- "Conditional average estimate"
names(Male_model_avg)[names(Male_model_avg) == "Std..Error"] <- "Standard Error"
names(Male_model_avg)[names(Male_model_avg) == "X2.5.."] <- "2.5% Interval"
names(Male_model_avg)[names(Male_model_avg) == "X97.5.."] <- "97.5% Interval"

pander(Male_model_avg, split.cell = 40, split.table = Inf, emphasize.strong.rows = 2, round = 3)

```


```{r male figure, fig.width= 8.5, fig.height= 6}

# predict.averaging does not return predictions for the conditional estimates (i.e. model coefficients averaged over models that contain the relevant predictor, rather than over the full specified subset). To predict mean estimates for each categorical variable, I can get these model averaged estimates by manually specifying the models I want to be avergaged. These are used only for plotting.

# First average models that contain the predictor focal haplotype. These were found by inspection of the top model list above.

focal_male_models <- get.models(male_dredge, subset = c("2", "4"))

focal_male_avg <- model.avg(focal_male_models)

# Note that the conditional averaged estimates from the male_avgm object are identical to the full averaged estimates for the focal_male_avg object for focal haplotype.

# Now average models that contain the social haplotype predictor.

social_male_models <- get.models(male_dredge, subset = c("4"))

# Note that there is only one model (the original full model) that contains social haplotype in the < 6 delta subset, so estimates are calculated directly from this model - no averaging occurs. The conditional averaged estimates from the male_avgm object are identical to the estimates from the full model.



# Focal new data

new_data_male <- Male_fitness %>%
  ungroup() %>%
  select(Focal_haplotype, Block, Strain, Individual) %>%
  mutate(Social_haplotype = "Barcelona", Block = "1", Strain = "Barcelona 1", Individual = "4") %>% 
  distinct() 


pred_male_focal <- predict(focal_male_avg, newdata = new_data_male, type = "response", se.fit = TRUE, re.form = NA) %>%
  unlist() %>% 
  as.data.frame()

pred_male_focal_1 <- pred_male_focal %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_male_focal_2 <- pred_male_focal %>% 
  slice(6:10) %>% 
  rename(SE = ".")
  
pred_focal_male <- cbind(new_data_male, pred_male_focal_1, pred_male_focal_2) %>% 
  rename(Proportion_focal = mean_estimate) %>% 
  mutate(Upper = Proportion_focal + SE,
         Lower = Proportion_focal - SE)

# Plot

Male_focal_plot <- Male_fitness %>%
  ggplot(aes(x = Focal_haplotype, y = Proportion_focal, fill = Focal_haplotype, colour = Focal_haplotype)) +
  geom_quasirandom(data = Male_fitness, width = 0.3, alpha =  0.3, pch = 21, colour = 'grey21', aes(size = Offspring_counted)) +
  scale_size_continuous(range = c(0.5, 6), labels = NULL, breaks = c(20, 40, 60, 80, 100, 120)) +
  scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  geom_point(data = pred_focal_male, aes(x = Focal_haplotype, y = Proportion_focal), size = 3, colour='black') +
  geom_errorbar(data = pred_focal_male, aes(x = Focal_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  labs(x = "Male mtDNA haplotype", y = "Proportion of offspring sired by focal male") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())


# Social new data

new_data_social_male <- Male_fitness %>%
  ungroup() %>%
  select(Social_haplotype, Block, Strain, Individual) %>%
  mutate(Focal_haplotype = "Barcelona", Block = "1", Strain = "Barcelona 1", Individual = "4") %>% 
  distinct()

# predict.averaging works over the full average rather than the conditional average that we present. I use a workaround where I create another model average object but only using the models in the < 6 delta subset that include social haplotype. Here only two models make the cut - the full model is the only one containing social haplotype as a predictor so no averaging is neccessary. Plug the full model into the predict function.

pred_male_social <- predict(male_binary_model, newdata = new_data_social_male, type = "response", se.fit = TRUE, re.form = NA) %>%
  unlist() %>% 
  as.data.frame()

pred_male_social_1 <- pred_male_social %>% 
  slice(1:5) %>% 
  rename(mean_estimate = ".")

pred_male_social_2 <- pred_male_social %>% 
  slice(6:10) %>% 
  rename(SE = ".")
  
pred_male_social <- cbind(new_data_social_male, pred_male_social_1, pred_male_social_2) %>% 
  rename(Proportion_focal = mean_estimate) %>% 
  mutate(Upper = Proportion_focal + SE,
         Lower = Proportion_focal - SE)
  

# Plot

Male_social_plot <- Male_fitness %>%
  ggplot(aes(x = Social_haplotype, y = Proportion_focal, fill = Social_haplotype, colour = Social_haplotype)) +
  geom_quasirandom(data = Male_fitness, width = 0.3, alpha =  0.3, pch = 21, colour = 'grey21', aes(size = Offspring_counted)) +
  scale_size_continuous(range = c(0.5, 6), labels = NULL, breaks = c(20, 40, 60, 80, 100, 120)) +
 scale_fill_manual(values = c("Barcelona" = "#fcde9c", "Brownsville" = "#f58670", "Dahomey" = "#e34f6f", "Israel" = "#d72d7c" , "Sweden" = "#7c1d6f")) +
  geom_point(data = pred_male_social, aes(x = Social_haplotype, y = Proportion_focal), size = 3, colour='black') +
  geom_errorbar(data = pred_male_social, aes(x = Social_haplotype, ymax = Upper, ymin = Lower, width = 0), colour = "black") +
  labs(x = "Female mtDNA haplotype", y = "Proportion of offspring sired by focal male") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(panel.grid.major.x = element_blank())

ggarrange(Male_focal_plot, Male_social_plot, labels = c("a", "b"))

```

**Figure 2**: The proportion of offspring produced by _mt_-strain males competing with standard _bw_ males. **a** shows the direct effect of mtDNA on male fitness. **b** shows the indirect genetic effect of female mtDNA on male fitness. Coloured points represent individual males, with larger points indicating a higher number of offspring produced in the vial (sired by either male). Black points show model predictions of the mean proportion of offspring sired by the _mt_-strain male, with associated standard errors.


# Raw data and reproducibility

### Table of raw data

For the purposes of completeness, transparency and data archiving, we include the raw data in this report.


**Table S6**: the raw data-set used in the present study, with NA values resulting from data collection mistakes removed (i.e. two females placed in competitive environment, no value recorded for whether the fly survived, flies that escaped during the experiment etc.).
```{r raw data}
kable(fitness_data %>% filter(!is.na(Survived)), "html") %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "800px")
```


Columns represent:

**Individual:** the focal fly being tested.

**Block:** the distinct period of time that the particular individual was tested.

**Strain:** Which of the 10 combinations of haplotype and duplicate strain was the individual from?

**Replicate:** A set of all possible combinations of the 5 haplotypes. Each replicate contained 25 cells.

**Sex:** was the focal individual female or male?

**Focal_haplotype:** what mtDNA haplotype did the focal individual carry?

**Social_haplotype:** what mtDNA haplotype did the social competitor of the focal individual carry?

**Survived:** did the focal individual survive to adulthood (1) or die during larval development (0)?

**Social_survival:** did the social competitor die as a larva (L), as a pupa (P) or survive to adulthood (N)?

**Dev_time:** how many hours did it take for the focal individual to progress from an egg to an adult. NA values indicate where individuals did not survive or development time could not be measured.

**Day:** how many days did it take the focal individual to develop?

**Hours:** lights were turned on at 7am every morning. How many hours did it take for individuals to eclose after this time?

**Wing_length:** what was the length in mm of the focal individuals right wing?

**Maternal_female_offspring:** how many adult female offspring did a focal female produce in a two day period?

**Maternal_male_offspring:** how many adult male offspring did a focal female produce in a two day period?

**Maternal_total_offspring:** how many adult offspring did a focal female produce in a two day period?

**Paternal_focal_offspring:** how many red-eye phenotype offspring were there across the two vials in the male adult fitness assay?

**Paternal_bw_offspring:** how many brown-eye phenotype offspring were there across the two vials in the male adult fitness assay?


### R session information

This section provides information on the operating system and R packages attached during the production of this document, to allow easier replication of the analysis.

```{r session info}
sessionInfo() %>% pander
```


# References
